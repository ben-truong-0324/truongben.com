<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Configuration & Business Alignment</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --tufts-blue: #3c91e6;
            --gunmetal: #272d2d;
            --ghost-white: #f6f8ff;
            --chili-red: #d64933;
            --xanthous: #e3b23c;
            --diagram-node-text: #FFFFFF; /* White text for better contrast on dark nodes */
        }

        body {
            background-color: var(--ghost-white);
            color: var(--gunmetal);
            font-family: 'Inter', sans-serif;
        }
        .header-title { color: var(--tufts-blue); }
        .header-subtitle { color: var(--gunmetal); }
        .section-title-border { border-bottom-color: var(--tufts-blue); }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            background: var(--tufts-blue);
            box-shadow: 0 0 0 2px var(--ghost-white), 0 0 0 4px var(--tufts-blue);
        }
        .slider-container input[type="range"]::-moz-range-thumb {
            background: var(--tufts-blue);
            box-shadow: 0 0 0 2px var(--ghost-white), 0 0 0 4px var(--tufts-blue);
        }
        .slider-container input[type="range"] { background: #d1d5db; }

        .explainer-box {
            background-color: white;
            border: 1px solid #e5e7eb;
            transition: all 0.3s ease;
        }
        .explainer-box:hover {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }
        .explainer-box-title { color: var(--gunmetal); }
        .explainer-box-description { color: var(--gunmetal); opacity: 0.9; }
        .tip-text { color: var(--tufts-blue); font-weight: 500; }
        .example-output-bg { background-color: var(--ghost-white); border: 1px solid #e5e7eb; }
        .token-probability-bar { transition: all 0.3s ease; }

        .tooltip {
            position: absolute;
            padding: 8px;
            background: rgba(39, 45, 45, 0.9); /* Gunmetal with opacity */
            color: var(--ghost-white);
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            z-index: 10;
        }
        .maxtokens-bar-color { background-color: var(--tufts-blue); }
        .footer-text { color: var(--gunmetal); opacity: 0.8; }

        .chart-container { /* Used for D3 diagrams */
            min-height: 220px; /* Adjusted for diagrams */
            width: 100%;
            transition: all 0.3s ease;
        }

        /* Styles for the new LLM Model Types section */
        .model-type-card {
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            border: 1px solid #e5e7eb;
        }
        .model-type-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--tufts-blue);
            margin-bottom: 0.75rem;
        }
        .model-type-description, .model-type-usecase {
            font-size: 0.875rem;
            color: var(--gunmetal);
            margin-bottom: 0.75rem;
            line-height: 1.5;
        }
        .model-type-usecase strong { color: var(--gunmetal); }
        /* Removed .model-type-visualization specific styling, will use .chart-container */

    </style>
</head>
<body class="bg-gray-50 font-sans">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <header class="mb-12 text-center">
            <h1 class="text-4xl font-bold header-title mb-2">LLM Configuration & Business Alignment</h1>
            <p class="text-xl header-subtitle">A visual guide to tuning Large Language Models for optimal performance</p>
        </header>

        <section class="mb-16">
            <h2 class="text-2xl font-semibold text-gray-800 mb-6 border-b pb-2 section-title-border">🔧 LLM Configuration Parameters</h2>
            
            <div class="bg-white rounded-lg shadow-md p-6 mb-8 explainer-box">
                <div class="flex flex-col md:flex-row gap-8">
                    <div class="w-full md:w-1/3">
                        <label for="temperature" class="block text-lg font-medium text-gray-700 mb-2">Temperature: <span id="temp-value" class="font-bold">0.7</span></label>
                        <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <div class="mt-4 text-sm explainer-box-description">
                            <p>Controls randomness: Lower values make outputs more deterministic, while higher values increase creativity.</p>
                            <p class="mt-2"><span class="tip-text">Tip:</span> Use lower values for factual tasks, higher for creative writing.</p>
                        </div>
                    </div>
                    <div class="w-full md:w-2/3 chart-container" id="temp-chart"></div>
                </div>
                <div class="mt-6 p-4 rounded-lg example-output-bg">
                    <h4 class="font-medium text-gray-700 mb-2">Example Output:</h4>
                    <p id="temp-example" class="text-gray-600 italic">"The capital of France is Paris, a beautiful city known for its iconic Eiffel Tower and rich cultural history..."</p>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 mb-8 explainer-box">
                <div class="flex flex-col md:flex-row gap-8">
                    <div class="w-full md:w-1/3">
                        <label for="top-p" class="block text-lg font-medium text-gray-700 mb-2">Top P: <span id="topp-value" class="font-bold">0.9</span></label>
                        <input type="range" id="top-p" min="0.1" max="1" step="0.1" value="0.9" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <div class="mt-4 text-sm explainer-box-description">
                            <p>Nucleus sampling: Only considers tokens whose cumulative probability exceeds this threshold.</p>
                            <p class="mt-2"><span class="tip-text">Tip:</span> Works well with temperature to balance diversity and quality.</p>
                        </div>
                    </div>
                    <div class="w-full md:w-2/3 chart-container" id="topp-chart"></div>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 mb-8 explainer-box">
                <div class="flex flex-col md:flex-row gap-8">
                    <div class="w-full md:w-1/3">
                        <label for="top-k" class="block text-lg font-medium text-gray-700 mb-2">Top K: <span id="topk-value" class="font-bold">50</span></label>
                        <input type="range" id="top-k" min="1" max="100" step="1" value="50" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <div class="mt-4 text-sm explainer-box-description">
                            <p>Limits sampling to the top K most probable tokens at each step.</p>
                            <p class="mt-2"><span class="tip-text">Tip:</span> Higher values increase diversity but may reduce coherence.</p>
                        </div>
                    </div>
                    <div class="w-full md:w-2/3 chart-container" id="topk-chart"></div>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 mb-8 explainer-box">
                <div class="flex flex-col md:flex-row gap-8">
                    <div class="w-full md:w-1/3">
                        <label for="max-tokens" class="block text-lg font-medium text-gray-700 mb-2">Max Tokens: <span id="maxtokens-value" class="font-bold">150</span></label>
                        <input type="range" id="max-tokens" min="20" max="500" step="10" value="150" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <div class="mt-4 text-sm explainer-box-description">
                            <p>Maximum number of tokens the model will generate in a single response.</p>
                            <p class="mt-2"><span class="tip-text">Tip:</span> Balance between completeness and cost/latency considerations.</p>
                        </div>
                    </div>
                    <div class="w-full md:w-2/3 chart-container" id="maxtokens-chart"></div>
                </div>
                <div class="mt-6 p-4 rounded-lg example-output-bg">
                    <h4 class="font-medium text-gray-700 mb-2">Output Length Preview:</h4>
                    <p id="maxtokens-example" class="text-gray-600 italic">"Artificial intelligence is transforming industries by enabling machines to perform tasks that typically require human intelligence. This includes..."</p>
                    <div class="w-full bg-gray-200 rounded-full h-2.5 mt-2">
                        <div id="maxtokens-bar" class="h-2.5 rounded-full maxtokens-bar-color" style="width: 30%"></div>
                    </div>
                </div>
            </div>

            <div class="bg-white rounded-lg shadow-md p-6 explainer-box">
                <div class="flex flex-col md:flex-row gap-8">
                    <div class="w-full md:w-1/3">
                        <label for="freq-penalty" class="block text-lg font-medium text-gray-700 mb-2">Frequency Penalty: <span id="freqpenalty-value" class="font-bold">0.5</span></label>
                        <input type="range" id="freq-penalty" min="0" max="2" step="0.1" value="0.5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        <div class="mt-4 text-sm explainer-box-description">
                            <p>Reduces the likelihood of repeating the same tokens in the output.</p>
                            <p class="mt-2"><span class="tip-text">Tip:</span> Useful for longer responses to avoid redundancy.</p>
                        </div>
                    </div>
                    <div class="w-full md:w-2/3 chart-container" id="freqpenalty-chart"></div>
                </div>
                <div class="mt-6 p-4 rounded-lg example-output-bg">
                    <h4 class="font-medium text-gray-700 mb-2">Token Repetition Analysis:</h4>
                    <p id="freqpenalty-example" class="text-gray-600 italic">"The quick brown fox jumps over the lazy dog. The quick brown fox is known for its agility. The quick brown fox..."</p>
                </div>
            </div>
        </section>

        <section class="mb-16">
            <h2 class="text-2xl font-semibold text-gray-800 mb-6 border-b pb-2 section-title-border">📊 Evaluation Metrics for LLM Outputs</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">Perplexity</h3>
                    <div class="chart-container !min-h-[250px]" id="perplexity-chart"></div> <div class="mt-4 text-sm explainer-box-description">
                        <p>Measures how well the model predicts a sample. Lower values indicate better performance.</p>
                        <p class="mt-2"><span class="tip-text">Use case:</span> Comparing different model architectures or training approaches.</p>
                    </div>
                </div>
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">ROUGE</h3>
                    <div class="chart-container !min-h-[250px]" id="rouge-chart"></div>
                    <div class="mt-4 text-sm explainer-box-description">
                        <p>Evaluates summarization quality by comparing to human references.</p>
                        <p class="mt-2"><span class="tip-text">Use case:</span> Testing summarization models.</p>
                    </div>
                </div>
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">BLEU</h3>
                    <div class="chart-container !min-h-[250px]" id="bleu-chart"></div>
                    <div class="mt-4 text-sm explainer-box-description">
                        <p>Measures translation quality by comparing to human references.</p>
                        <p class="mt-2"><span class="tip-text">Use case:</span> Evaluating machine translation systems.</p>
                    </div>
                </div>
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">BERTScore</h3>
                    <div class="chart-container !min-h-[250px]" id="bertscore-chart"></div>
                    <div class="mt-4 text-sm explainer-box-description">
                        <p>Evaluates semantic similarity using BERT embeddings.</p>
                        <p class="mt-2"><span class="tip-text">Use case:</span> When meaning is key.</p>
                    </div>
                </div>
                <div class="explainer-box p-6 col-span-1 md:col-span-2">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">Hallucination Rate</h3>
                    <div class="chart-container !min-h-[250px]" id="hallucination-chart"></div>
                     <div class="mt-4 text-sm explainer-box-description">
                        <p>Percentage of factually incorrect or unsupported statements.</p>
                        <p class="mt-2"><span class="tip-text">Use case:</span> Critical for high-accuracy applications.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="mb-16">
            <h2 class="text-2xl font-semibold text-gray-800 mb-6 border-b pb-2 section-title-border">💼 Business-Oriented Metrics</h2>
             <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">Latency Comparison</h3>
                    <div class="chart-container !min-h-[250px]" id="latency-chart"></div>
                    <div class="mt-4 text-sm explainer-box-description">
                        <p>Response time in milliseconds across different model providers.</p>
                        <p class="mt-2"><span class="tip-text">Business impact:</span> Directly affects user experience and engagement.</p>
                    </div>
                </div>
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">Cost per Token</h3>
                    <div class="chart-container !min-h-[250px]" id="cost-chart"></div>
                    <div class="mt-4 text-sm explainer-box-description">
                        <p>Comparative cost analysis across different model options.</p>
                        <p class="mt-2"><span class="tip-text">Business impact:</span> Scales with usage volume - critical for high-traffic applications.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="mb-16">
            <h2 class="text-2xl font-semibold text-gray-800 mb-6 border-b pb-2 section-title-border">🚀 Advanced Capabilities</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">Retrieval-Augmented Generation (RAG)</h3>
                    <div class="chart-container" id="rag-diagram"></div> {/* Changed from placeholder div to chart-container */}
                    <div class="mt-4 text-sm explainer-box-description">
                        <p>Combines LLMs with external knowledge retrieval to improve factual accuracy.</p>
                        <p class="mt-2"><span class="tip-text">Business value:</span> Enables up-to-date, domain-specific responses without retraining.</p>
                    </div>
                </div>
                <div class="explainer-box p-6">
                    <h3 class="text-lg font-medium explainer-box-title mb-4">Fine-Tuning Process</h3>
                     <div class="chart-container" id="finetune-diagram"></div> {/* Changed from placeholder div to chart-container */}
                    <div class="mt-4 text-sm explainer-box-description">
                        <p>Adapts a base model to specific domains or tasks using additional training data.</p>
                        <p class="mt-2"><span class="tip-text">Business value:</span> Creates specialized models that outperform general-purpose ones for specific use cases.</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="mb-16">
            <h2 class="text-2xl font-semibold text-gray-800 mb-6 border-b pb-2 section-title-border">🧠 Understanding LLM Model Architectures</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="model-type-card">
                    <h3 class="model-type-title">Base Model</h3>
                    <p class="model-type-description">
                        Primarily trained to predict the next token in a sequence given the previous tokens. They learn grammar, facts, and reasoning capabilities from vast amounts of text data.
                    </p>
                    <p class="model-type-usecase"><strong>Core Function:</strong> Next-token prediction.</p>
                    <p class="model-type-usecase"><strong>Examples:</strong> Text completion, foundational layer for other model types.</p>
                    <div class="chart-container" id="base-model-diagram"></div> {/* Use chart-container */}
                </div>
                <div class="model-type-card">
                    <h3 class="model-type-title">Instruct Model</h3>
                    <p class="model-type-description">
                        Fine-tuned from a base model to follow instructions. They are trained on datasets of (instruction, response) pairs, enabling them to perform specific tasks as directed.
                    </p>
                    <p class="model-type-usecase"><strong>Core Function:</strong> Follow direct prompts and tasks.</p>
                    <p class="model-type-usecase"><strong>Examples:</strong> Summarization, translation, Q&A, code generation.</p>
                    <div class="chart-container" id="instruct-model-diagram"></div> {/* Use chart-container */}
                </div>
                <div class="model-type-card">
                    <h3 class="model-type-title">Chat Model</h3>
                    <p class="model-type-description">
                        Further fine-tuned (often from instruct models) for conversational interactions. They are trained on dialogue data and often incorporate techniques like Reinforcement Learning from Human Feedback (RLHF) for better alignment, helpfulness, and safety in a conversational context. They can maintain context over multiple turns.
                    </p>
                    <p class="model-type-usecase"><strong>Core Function:</strong> Conversational interaction with memory and alignment.</p>
                    <p class="model-type-usecase"><strong>Examples:</strong> Chatbots, virtual assistants, customer service agents.</p>
                    <div class="chart-container" id="chat-model-diagram"></div> {/* Use chart-container */}
                </div>
                <div class="model-type-card">
                    <h3 class="model-type-title">Mixture of Experts (MoE) Model</h3>
                    <p class="model-type-description">
                        An MoE consists of many smaller "expert" sub-models. A gating network determines which experts to route a given input token to. This allows models to scale to much larger parameter counts with roughly constant computational cost per token.
                    </p>
                    <p class="model-type-usecase"><strong>Core Function:</strong> Efficiently scale model size by selectively activating expert sub-networks.</p>
                    <p class="model-type-usecase"><strong>Examples:</strong> High-performance LLMs, specialized knowledge tasks.</p>
                    <div class="chart-container" id="moe-model-diagram"></div> {/* Use chart-container */}
                </div>
            </div>
        </section>

        <footer class="mt-16 text-center footer-text text-sm">
            <p>Interactive LLM Configuration Guide | Created for educational purposes</p>
            <p class="mt-2">Data shown is simulated for demonstration</p>
        </footer>
    </div>

    <script>
        // Tooltip setup
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        // Get colors from CSS variables
        const tuftsBlue = getComputedStyle(document.documentElement).getPropertyValue('--tufts-blue').trim();
        const gunmetal = getComputedStyle(document.documentElement).getPropertyValue('--gunmetal').trim();
        const ghostWhite = getComputedStyle(document.documentElement).getPropertyValue('--ghost-white').trim();
        const chiliRed = getComputedStyle(document.documentElement).getPropertyValue('--chili-red').trim();
        const xanthous = getComputedStyle(document.documentElement).getPropertyValue('--xanthous').trim();
        const diagramNodeText = getComputedStyle(document.documentElement).getPropertyValue('--diagram-node-text').trim();

        const colorScale = d3.scaleSequential(d3.interpolate(ghostWhite, tuftsBlue)).domain([0, 1]);
        const vendorColor = d3.scaleOrdinal().domain(["OpenAI", "Anthropic", "Open Source"]).range([tuftsBlue, chiliRed, xanthous]);

        function generateRandomData(count, min, max) {
            return Array.from({length: count}, () => Math.random() * (max - min) + min);
        }

        // Section 1: Configuration Parameters ( 그대로 유지, CSS 변수 사용 확인 )
         function initConfigurationCharts() {
            function updateBarChart(chartId, data, xDomainFormat = i => i, yTickFormat = d => `${(d*100).toFixed(0)}%`, chartTitle = "Token Probability Distribution", highlightCondition = (d,i,value) => false, highlightColor = chiliRed, baseColor = tuftsBlue, lineValue = null, lineColor = chiliRed) {
                const margin = {top: 30, right: 20, bottom: 40, left: 50};
                const container = document.getElementById(chartId);
                if (!container) return;
                const width = container.clientWidth - margin.left - margin.right;
                const height = 250 - margin.top - margin.bottom;
                
                d3.select(`#${chartId}`).selectAll("*").remove();
                
                const svg = d3.select(`#${chartId}`)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                const x = d3.scaleBand()
                    .domain(d3.range(data.length))
                    .range([0, width])
                    .padding(0.1);
                
                const y = d3.scaleLinear()
                    .domain([0, d3.max(data) > 0 ? d3.max(data) : 1]) 
                    .range([height, 0]);
                
                svg.selectAll(".bar")
                    .data(data)
                    .enter()
                    .append("rect")
                    .attr("class", "token-probability-bar")
                    .attr("x", (d, i) => x(i))
                    .attr("y", d => y(d))
                    .attr("width", x.bandwidth())
                    .attr("height", d => height - y(d))
                    .attr("fill", (d, i) => highlightCondition(d,i, lineValue ? lineValue.value : null) ? highlightColor : baseColor) 
                    .on("mouseover", function(event, d_val) {
                        tooltip.transition().duration(200).style("opacity", .9);
                        tooltip.html(`Probability: ${(d_val*100).toFixed(1)}%`)
                            .style("left", (event.pageX + 5) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function() {
                        tooltip.transition().duration(500).style("opacity", 0);
                    });
                
                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).tickFormat(xDomainFormat).tickSize(0));
                
                svg.append("g")
                    .call(d3.axisLeft(y).ticks(5).tickFormat(yTickFormat));
                
                svg.append("text")
                    .attr("x", width/2)
                    .attr("y", -10)
                    .attr("text-anchor", "middle")
                    .style("fill", gunmetal)
                    .text(chartTitle);

                if (lineValue !== null && typeof lineValue.value !== 'undefined' && typeof lineValue.text !== 'undefined' ) { 
                     if (lineValue.isVertical) {
                        const lineX = x(lineValue.value -0.5);
                        if (typeof lineX !== 'undefined') { // Check if x value is valid
                            svg.append("line")
                                .attr("x1", lineX )
                                .attr("x2", lineX )
                                .attr("y1", 0)
                                .attr("y2", height)
                                .attr("stroke", lineColor)
                                .attr("stroke-width", 2)
                                .attr("stroke-dasharray", "5,5");
                            svg.append("text")
                                .attr("x", lineX + 5)
                                .attr("y", 20)
                                .text(lineValue.text)
                                .style("fill", lineColor);
                        }
                     } else {
                        svg.append("line")
                            .attr("x1", 0)
                            .attr("x2", width)
                            .attr("y1", y(lineValue.value))
                            .attr("y2", y(lineValue.value))
                            .attr("stroke", lineColor)
                            .attr("stroke-width", 2)
                            .attr("stroke-dasharray", "5,5");
                        svg.append("text")
                            .attr("x", width - 10)
                            .attr("y", y(lineValue.value) - 5)
                            .attr("text-anchor", "end")
                            .text(lineValue.text)
                            .style("fill", lineColor);
                     }
                }
            }

            function updateTempChart(value) { /* ... same as before, ensure baseColor=tuftsBlue ... */
                let data = generateRandomData(15, 0.01, 1); 
                data.sort((a, b) => b - a);
                const tempData = data.map(d => Math.exp(Math.log(d) / value));
                const sumTempData = tempData.reduce((sum, val) => sum + val, 0);
                const normalizedTempData = sumTempData > 0 ? tempData.map(d => d / sumTempData) : Array(tempData.length).fill(0);
                updateBarChart('temp-chart', normalizedTempData, i => (i === 0 ? "Most likely" : ""), d => `${(d*100).toFixed(0)}%`, "Token Probability (Temperature Adjusted)", (d,i,v) => false, chiliRed, tuftsBlue);
            }
            function updateTopPChart(value) { /* ... same, ensure colors from palette ... */
                let data = generateRandomData(15, 0, 1);
                data.sort((a, b) => b - a);
                const sumProbs = data.reduce((s, p) => s + p, 0);
                const normalizedData = sumProbs > 0 ? data.map(p => p / sumProbs) : Array(data.length).fill(0);
                let cumulativeProb = 0;
                const displayData = normalizedData.map(p => {
                    const originalCumulative = cumulativeProb;
                    cumulativeProb += p;
                    return { prob: p, inNucleus: originalCumulative < value };
                });
                updateBarChart('topp-chart', displayData.map(d => d.prob), i => (i === 0 ? "Most likely" : ""), d => `${(d*100).toFixed(0)}%`, "Token Probabilities (Top-P Nucleus)", (d, i, val) => !displayData[i].inNucleus, '#cccccc', tuftsBlue, { value: value, text: `Top P = ${value.toFixed(1)}`, isVertical: false }, chiliRed);
            }
            function updateTopKChart(value) { /* ... same, ensure colors from palette ... */
                let data = generateRandomData(20, 0, 1);
                data.sort((a, b) => b - a);
                const sumProbs = data.reduce((s, p) => s + p, 0);
                const normalizedData = sumProbs > 0 ? data.map(p => p / sumProbs) : Array(data.length).fill(0);
                updateBarChart('topk-chart', normalizedData, i => (i === 0 ? "Most likely" : ""), d => `${(d*100).toFixed(0)}%`, "Token Probabilities (Top-K Highlighted)", (d,i) => i >= value, '#cccccc', tuftsBlue, { value: value, text: `Top K = ${value}`, isVertical: true }, chiliRed);
            }
            function updateMaxTokensChart(value) { /* ... same, ensure colors ... */
                const sampleText = "Large language models are transforming how we interact with technology. These AI systems can understand and generate human-like text, enabling applications like chatbots, content creation, and code generation. The key advantage is their ability to handle a wide range of tasks without task-specific training. However, they require careful tuning of parameters like temperature and top-p sampling to produce optimal results. When configured properly, they can significantly enhance productivity across many industries.";
                d3.select("#maxtokens-chart").selectAll("*").remove();
                const margin = {top: 30, right: 20, bottom: 40, left: 50};
                const container = document.getElementById('maxtokens-chart');
                if (!container) return;
                const width = container.clientWidth - margin.left - margin.right;
                const height = 250 - margin.top - margin.bottom;
                const svg = d3.select("#maxtokens-chart").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleLinear().domain([0, 500]).range([0, width]);
                svg.append("rect").attr("x", 0).attr("y", height * 0.4).attr("width", x(value)).attr("height", height * 0.2).attr("fill", tuftsBlue);
                svg.append("line").attr("x1", x(value)).attr("x2", x(value)).attr("y1", 0).attr("y2", height).attr("stroke", chiliRed).attr("stroke-width", 2).attr("stroke-dasharray", "5,5");
                svg.append("text").attr("x", x(value) > 30 ? x(value) - 5 : x(value) + 5).attr("y", height * 0.3).attr("text-anchor", x(value) > 30 ? "end" : "start").text(`${value} tokens`).style("fill", chiliRed);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(5));
                svg.append("text").attr("x", width/2).attr("y", -10).attr("text-anchor", "middle").style("fill", gunmetal).text("Output Token Limit");
                const approxWords = Math.floor(value * 0.75);
                const truncatedText = sampleText.split(" ").slice(0, approxWords).join(" ");
                document.getElementById("maxtokens-example").textContent = truncatedText + (value < 500 ? "..." : "");
                document.getElementById("maxtokens-bar").style.width = `${(value/500)*100}%`;
            }
            function updateFreqPenaltyChart(value) { /* ... same, ensure colors ... */
                const tokens = ["the", "fox", "is", "quick", "brown", "dog"];
                const baseProbs = [0.25, 0.1, 0.15, 0.2, 0.15, 0.15];
                const penalizedProbs = baseProbs.map(p => Math.max(0, p - (value * p * 0.5))); 
                const data = tokens.map((token, i) => ({token, base: baseProbs[i], adjusted: penalizedProbs[i]}));
                d3.select("#freqpenalty-chart").selectAll("*").remove();
                const margin = {top: 30, right: 20, bottom: 40, left: 50};
                const container = document.getElementById('freqpenalty-chart');
                if(!container) return;
                const width = container.clientWidth - margin.left - margin.right;
                const height = 250 - margin.top - margin.bottom;
                const svg = d3.select("#freqpenalty-chart").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleBand().domain(tokens).range([0, width]).padding(0.2);
                const y = d3.scaleLinear().domain([0, d3.max(baseProbs)]).range([height, 0]);
                svg.selectAll(".base-bar").data(data).enter().append("rect").attr("x", d => x(d.token)).attr("y", d => y(d.base)).attr("width", x.bandwidth() / 2).attr("height", d => height - y(d.base)).attr("fill", "#cccccc");
                svg.selectAll(".adj-bar").data(data).enter().append("rect").attr("x", d => x(d.token) + x.bandwidth() / 2).attr("y", d => y(d.adjusted)).attr("width", x.bandwidth() / 2).attr("height", d => height - y(d.adjusted)).attr("fill", tuftsBlue);
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
                svg.append("g").call(d3.axisLeft(y).ticks(5).tickFormat(d => `${(d*100).toFixed(0)}%`));
                svg.append("text").attr("x", width/2).attr("y", -10).attr("text-anchor", "middle").style("fill", gunmetal).text("Token Probability (Base vs. Penalized)");
                let example = "";
                tokens.forEach((token, i) => { const reps = Math.max(1, Math.round(penalizedProbs[i] * 10)); example += `${token} `.repeat(reps > 0 ? reps : 1); });
                document.getElementById("freqpenalty-example").textContent = example.trim() + "...";
            }
            
            updateTempChart(parseFloat(document.getElementById("temperature").value));
            updateTopPChart(parseFloat(document.getElementById("top-p").value));
            updateTopKChart(parseInt(document.getElementById("top-k").value));
            updateMaxTokensChart(parseInt(document.getElementById("max-tokens").value));
            updateFreqPenaltyChart(parseFloat(document.getElementById("freq-penalty").value));
            
            document.getElementById("temperature").addEventListener("input", function() { const val = parseFloat(this.value); document.getElementById("temp-value").textContent = val.toFixed(1); updateTempChart(val); /* example text update */ });
            document.getElementById("top-p").addEventListener("input", function() { const val = parseFloat(this.value); document.getElementById("topp-value").textContent = val.toFixed(1); updateTopPChart(val); });
            document.getElementById("top-k").addEventListener("input", function() { const val = parseInt(this.value); document.getElementById("topk-value").textContent = val; updateTopKChart(val); });
            document.getElementById("max-tokens").addEventListener("input", function() { const val = parseInt(this.value); document.getElementById("maxtokens-value").textContent = val; updateMaxTokensChart(val); });
            document.getElementById("freq-penalty").addEventListener("input", function() { const val = parseFloat(this.value); document.getElementById("freqpenalty-value").textContent = val.toFixed(1); updateFreqPenaltyChart(val); });
        }

        // Section 2: Evaluation Metrics ( 그대로 유지, CSS 변수 사용 확인 )
        function initEvaluationCharts() { /* ... same as before, ensuring barFillColors use new palette vars ... */ 
            function createSimpleBarChart(chartId, data, xLabel, yLabel, yDomain = [0,1], barFillColor = tuftsBlue, valueFormat = d => d.toFixed(2)) {
                const margin = {top: 30, right: 20, bottom: 50, left: 60};
                const container = document.getElementById(chartId);
                if (!container) return;
                const width = container.clientWidth - margin.left - margin.right;
                const height = 200 - margin.top - margin.bottom;
                d3.select(`#${chartId}`).selectAll("*").remove();
                const svg = d3.select(`#${chartId}`).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleBand().domain(data.map(d => d.name)).range([0, width]).padding(0.2);
                const y = d3.scaleLinear().domain(yDomain).range([height, 0]);
                svg.selectAll(".bar").data(data).enter().append("rect").attr("x", d => x(d.name)).attr("y", d => y(d.value)).attr("width", x.bandwidth()).attr("height", d => height - y(d.value)).attr("fill", barFillColor);
                svg.selectAll(".bar-value").data(data).enter().append("text").attr("x", d => x(d.name) + x.bandwidth() / 2).attr("y", d => y(d.value) - 5).attr("text-anchor", "middle").style("font-size", "10px").style("fill", gunmetal).text(d => valueFormat(d.value));
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
                svg.append("g").call(d3.axisLeft(y).ticks(5).tickFormat(yDomain[1] <=1 && yLabel.toLowerCase().includes("score") ? d3.format(".0%") : d3.format(",")));
                svg.append("text").attr("x", width/2).attr("y", height + margin.bottom - 15).attr("text-anchor", "middle").style("fill", gunmetal).text(xLabel);
                svg.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left + 15).attr("x", -height/2).attr("text-anchor", "middle").style("fill", gunmetal).text(yLabel);
            }
            createSimpleBarChart('perplexity-chart', [{name: "M1", value:30}, {name:"M2", value:22}, {name:"M3", value:45}], "Model", "Perplexity", [0,60], chiliRed, d => d.toFixed(0));
            createSimpleBarChart('rouge-chart', [{name: "R-1", value:0.45}, {name:"R-2", value:0.32}, {name:"R-L", value:0.40}], "ROUGE Metric", "F1 Score", [0,1], tuftsBlue);
            createSimpleBarChart('bleu-chart', [{name: "SysA", value:28}, {name:"SysB", value:35}, {name:"SysC", value:31}], "System", "BLEU Score", [0,50], xanthous, d => d.toFixed(0));
            createSimpleBarChart('bertscore-chart', [{name: "OutX", value:0.88}, {name:"OutY", value:0.92}, {name:"OutZ", value:0.85}], "Output", "BERTScore F1", [0.8,1], tuftsBlue); // BERTScore typically 0-1
            createSimpleBarChart('hallucination-chart', [{name: "M-Base", value:0.15}, {name:"M-Tuned", value:0.06}, {name:"M-RAG", value:0.03}], "Model Config", "Hallucination Rate", [0,0.2], chiliRed);
        }


        // Section 3: Business Metrics ( 그대로 유지, CSS 변수 사용 확인 )
        function initBusinessCharts() { /* ... same as before, ensuring barFillColors use new palette vars ... */ 
            function createLatencyCostChart(chartId, data, xLabel, yLabel, yDomain, barFillColors = [tuftsBlue, xanthous, chiliRed], valueFormat = d => d.toFixed(0)) {
                const margin = {top: 30, right: 20, bottom: 50, left: 60};
                const container = document.getElementById(chartId);
                if (!container) return;
                const width = container.clientWidth - margin.left - margin.right;
                const height = 200 - margin.top - margin.bottom; 
                d3.select(`#${chartId}`).selectAll("*").remove();
                const svg = d3.select(`#${chartId}`).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                const x = d3.scaleBand().domain(data.map(d => d.name)).range([0, width]).padding(0.2);
                const y = d3.scaleLinear().domain(yDomain).range([height, 0]);
                svg.selectAll(".bar").data(data).enter().append("rect").attr("x", d => x(d.name)).attr("y", d => y(d.value)).attr("width", x.bandwidth()).attr("height", d => height - y(d.value)).attr("fill", (d,i) => barFillColors[i % barFillColors.length]);
                svg.selectAll(".bar-value").data(data).enter().append("text").attr("x", d => x(d.name) + x.bandwidth() / 2).attr("y", d => y(d.value) - 5).attr("text-anchor", "middle").style("font-size", "10px").style("fill", gunmetal).text(d => valueFormat(d.value));
                svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
                svg.append("g").call(d3.axisLeft(y).ticks(5).tickFormat(yLabel.toLowerCase().includes("cost") ? d3.format("$.3f") : d3.format(",")));
                svg.append("text").attr("x", width/2).attr("y", height + margin.bottom - 15).attr("text-anchor", "middle").style("fill", gunmetal).text(xLabel);
                svg.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left + 15).attr("x", -height/2).attr("text-anchor", "middle").style("fill", gunmetal).text(yLabel);
            }
            createLatencyCostChart('latency-chart', [{name: "GPT-4o", value:350}, {name:"Claude-3S", value:450}, {name:"Llama3-70B", value:600}], "Model Provider", "Latency (ms)", [0,800], [tuftsBlue, xanthous, chiliRed], d => `${d}ms`);
            createLatencyCostChart('cost-chart', [{name: "GPT-4o", value:0.005}, {name:"Claude-3S", value:0.003}, {name:"Llama3-70B", value:0.001}], "Model Provider", "Cost per 1k Tokens ($)", [0,0.007], [tuftsBlue, xanthous, chiliRed], d => `$${d.toFixed(3)}`);
        }


        // Section 4 & 5: Advanced Capabilities & Model Types
        function initAdvancedAndModelTypeVisuals() {
            const nodeW = 100, nodeH = 40, nodeRx = 5, nodeRy = 5;
            const textColor = diagramNodeText; // White text on dark nodes
            const lineColor = gunmetal;

            // Helper to create a standard diagram SVG
            function createDiagramSvg(containerId) {
                const margin = {top: 20, right: 20, bottom: 20, left: 20};
                const container = document.getElementById(containerId);
                 if (!container) { console.error(`Container ${containerId} not found`); return null;}
                d3.select(`#${containerId}`).selectAll("*").remove(); // Clear previous
                const width = container.clientWidth - margin.left - margin.right;
                const height = parseFloat(d3.select(container).style('min-height')) - margin.top - margin.bottom -10; // use min-height from style

                const svg = d3.select(`#${containerId}`)
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);
                
                // Define arrowhead (once per page is better, but this is robust)
                if (!d3.select("defs marker#arrowhead").node()) {
                    svg.append("defs").append("marker")
                        .attr("id", "arrowhead")
                        .attr("viewBox", "0 -5 10 10")
                        .attr("refX", 8)
                        .attr("refY", 0)
                        .attr("orient", "auto")
                        .attr("markerWidth", 6)
                        .attr("markerHeight", 6)
                        .append("path")
                        .attr("d", "M0,-5L10,0L0,5")
                        .attr("fill", lineColor);
                }
                return { svg, width, height };
            }

            function drawNodesAndLinks(svg, width, height, nodesSpec, linksSpec) {
                nodesSpec.forEach(node => {
                    svg.append("rect")
                        .attr("x", node.x - node.w/2)
                        .attr("y", node.y - node.h/2)
                        .attr("width", node.w)
                        .attr("height", node.h)
                        .attr("rx", nodeRx).attr("ry", nodeRy)
                        .attr("fill", node.color)
                        .attr("stroke", lineColor);
                    svg.append("text")
                        .attr("x", node.x)
                        .attr("y", node.y)
                        .attr("text-anchor", "middle").attr("dy", "0.35em")
                        .text(node.text).style("fill", textColor).style("font-size", "10px");
                });

                linksSpec.forEach(link => {
                    svg.append("path")
                        .attr("d", `M${link.source.x + link.source.w/2 * (link.sx || 0)},${link.source.y + link.source.h/2 * (link.sy || 0)} L${link.target.x - link.target.w/2 * (link.tx || 0)},${link.target.y - link.target.h/2 * (link.ty || 0)}`)
                        .attr("stroke", lineColor).attr("stroke-width", 2).attr("fill", "none")
                        .attr("marker-end", "url(#arrowhead)");
                });
            }
            
            // RAG Diagram (Restored from original logic)
            function createRAGDiagram() {
                const res = createDiagramSvg('rag-diagram');
                if (!res) return;
                const { svg, width, height } = res;

                constcenterY = height / 2;
                const nodeWidth = width / 5;
                const gap = 20;

                const nodes = [
                    { id: "query", x: nodeWidth * 0.5, y: centerY, w: nodeW, h: nodeH, text: "User Query", color: tuftsBlue },
                    { id: "retriever", x: nodeWidth * 1.5 + gap, y: centerY, w: nodeW, h: nodeH, text: "Retriever", color: xanthous },
                    { id: "docs", x: nodeWidth * 2.5 + gap*2, y: centerY - nodeH, w: nodeW, h: nodeH, text: "Documents", color: ghostWhite, colorText: gunmetal }, // Use ghostWhite for docs
                    { id: "llm", x: nodeWidth * 2.5 + gap*2, y: centerY + nodeH, w: nodeW, h: nodeH, text: "LLM", color: chiliRed },
                    { id: "response", x: nodeWidth * 4 + gap*3, y: centerY, w: nodeW, h: nodeH, text: "Response", color: gunmetal }
                ];
                 nodes.find(n=>n.id==="docs").textColor = gunmetal; // Special case for light background

                const links = [
                    { source: nodes[0], target: nodes[1], sx:1, tx:1 }, // Query -> Retriever
                    { source: nodes[1], target: nodes[2], sx:1, ty:-1, tx:1 }, // Retriever -> Docs (upper)
                    { source: nodes[1], target: nodes[3], sx:1, ty:1, tx:1  }, // Retriever -> LLM (lower)
                    { source: nodes[2], target: nodes[4], sx:1, tx:1 }, // Docs -> Response
                    { source: nodes[3], target: nodes[4], sx:1, tx:1 }  // LLM -> Response
                ];
                
                nodes.forEach(node => {
                    svg.append("rect").attr("x", node.x - node.w/2).attr("y", node.y - node.h/2).attr("width", node.w).attr("height", node.h).attr("rx", nodeRx).attr("ry", nodeRy).attr("fill", node.color).attr("stroke", lineColor);
                    svg.append("text").attr("x", node.x).attr("y", node.y).attr("text-anchor", "middle").attr("dy", "0.35em").text(node.text).style("fill", node.textColor || textColor).style("font-size", "10px");
                });
                links.forEach(link => {
                    let sourceNode = link.source; let targetNode = link.target;
                    svg.append("path").attr("d", `M${sourceNode.x + sourceNode.w/2},${sourceNode.y} L${targetNode.x-targetNode.w/2},${targetNode.y}`).attr("stroke", lineColor).attr("stroke-width", 2).attr("fill", "none").attr("marker-end", "url(#arrowhead)");
                });
            }

            // Fine-Tune Diagram (Restored from original logic)
            function createFineTuneDiagram() {
                const res = createDiagramSvg('finetune-diagram');
                 if (!res) return;
                const { svg, width, height } = res;

                const nodeRadius = width / 12; // Circle radius based on width
                constcenterY = height / 2;
                const stepX = width / 4.5;

                const nodes = [
                    { x: stepX * 0.7, y: centerY, text: "Base Model", color: tuftsBlue, r: nodeRadius },
                    { x: stepX * 1.7, y: centerY, text: "Domain Data", color: xanthous, r: nodeRadius },
                    { x: stepX * 2.7, y: centerY, text: "Training", color: chiliRed, r: nodeRadius },
                    { x: stepX * 3.7, y: centerY, text: "Fine-Tuned", color: gunmetal, r: nodeRadius }
                ];

                nodes.forEach((node, i) => {
                    svg.append("circle").attr("cx", node.x).attr("cy", node.y).attr("r", node.r).attr("fill", node.color).attr("stroke", lineColor);
                    svg.append("text").attr("x", node.x).attr("y", node.y).attr("text-anchor", "middle").attr("dy", "0.35em").text(i+1).style("fill", textColor).style("font-size", "12px");
                    svg.append("text").attr("x", node.x).attr("y", node.y + node.r + 15).attr("text-anchor", "middle").text(node.text).style("font-size", "10px").style("fill", gunmetal);
                });

                for (let i = 0; i < nodes.length - 1; i++) {
                    svg.append("line").attr("x1", nodes[i].x + nodes[i].r).attr("y1", nodes[i].y).attr("x2", nodes[i+1].x - nodes[i+1].r).attr("y2", nodes[i+1].y).attr("stroke", lineColor).attr("stroke-width", 2).attr("marker-end", i === nodes.length - 2 ? "url(#arrowhead)" : null);
                }
            }
            
            // New Model Type Diagrams
            function createBaseModelDiagram() {
                const res = createDiagramSvg('base-model-diagram'); if (!res) return;
                const { svg, width, height } = res;
                const nodes = [ { x: width/4, y: height/2, w:nodeW, h:nodeH, text: "Input: 'The sky is'", color: tuftsBlue }, { x: 3*width/4, y: height/2, w:nodeW, h:nodeH, text: "Output: '...blue'", color: gunmetal } ];
                const links = [ { source: nodes[0], target: nodes[1], sx:1, tx:1 } ];
                drawNodesAndLinks(svg, width, height, nodes, links);
            }

            function createInstructModelDiagram() {
                const res = createDiagramSvg('instruct-model-diagram'); if (!res) return;
                const { svg, width, height } = res;
                const nodes = [ { x: width/4, y: height/2, w:nodeW+20, h:nodeH+10, text: "Instruction: 'Summarize this text...'", color: xanthous }, { x: 3*width/4, y: height/2, w:nodeW+20, h:nodeH, text: "Output: '[Concise Summary]'", color: gunmetal } ];
                const links = [ { source: nodes[0], target: nodes[1], sx:1, tx:1 } ];
                drawNodesAndLinks(svg, width, height, nodes, links);
            }

            function createChatModelDiagram() {
                const res = createDiagramSvg('chat-model-diagram'); if (!res) return;
                const { svg, width, height } = res;
                const nodeWidth = width / 3.5;
                const nodes = [
                    { x: nodeWidth * 0.7, y: height/3, w:nodeW, h:nodeH, text: "User: 'Hi!'", color: tuftsBlue },
                    { x: nodeWidth * 2.3, y: height/3, w:nodeW, h:nodeH, text: "LLM: 'Hello!'", color: gunmetal },
                    { x: nodeWidth * 0.7, y: 2*height/3, w:nodeW, h:nodeH, text: "User: 'Weather?'", color: tuftsBlue },
                    { x: nodeWidth * 2.3, y: 2*height/3, w:nodeW, h:nodeH, text: "LLM: 'Sunny.' (Context)", color: gunmetal }
                ];
                const links = [
                    { source: nodes[0], target: nodes[1], sx:1, tx:1 }, { source: nodes[1], target: nodes[2], sy:1, ty:-1 }, // LLM -> Next User (conceptually)
                    { source: nodes[2], target: nodes[3], sx:1, tx:1 }
                ];
                drawNodesAndLinks(svg, width, height, nodes, links);
            }

            function createMoEDiagram() {
                const res = createDiagramSvg('moe-model-diagram'); if (!res) return;
                const { svg, width, height } = res;
                constcenterY = height / 2;
                constcenterX = width / 2;
                const expertYOffset = 50;
                const expertXSpread = 60;

                const nodes = [
                    { x: centerX, y: centerY - 70, w:nodeW, h:nodeH, text: "Input Token", color: tuftsBlue },
                    { x: centerX, y: centerY - 25, w:nodeW, h:nodeH, text: "Gating Network", color: xanthous },
                    { x: centerX - expertXSpread, y: centerY + expertYOffset, w:nodeW-20, h:nodeH-10,text: "Expert A", color: chiliRed },
                    { x: centerX, y: centerY + expertYOffset, w:nodeW-20, h:nodeH-10,text: "Expert B", color: chiliRed, stroke: tuftsBlue, strokeW: 3 }, // Highlighted expert
                    { x: centerX + expertXSpread, y: centerY + expertYOffset, w:nodeW-20, h:nodeH-10,text: "Expert C", color: chiliRed },
                    { x: centerX, y: centerY + expertYOffset + 60, w:nodeW, h:nodeH,text: "Combined Output", color: gunmetal }
                ];
                 nodes.forEach(node => { // Add stroke to highlighted
                    if(node.stroke) {
                        svg.append("rect").attr("x", node.x - node.w/2 - node.strokeW).attr("y", node.y - node.h/2-node.strokeW)
                           .attr("width", node.w + 2*node.strokeW).attr("height", node.h+2*node.strokeW)
                           .attr("rx", nodeRx+node.strokeW).attr("ry", nodeRy+node.strokeW).attr("fill", node.stroke);
                    }
                });

                const links = [
                    { source: nodes[0], target: nodes[1], sy:1, ty:-1 },
                    { source: nodes[1], target: nodes[2], sy:1, ty:-1 }, // Gate to Expert A
                    { source: nodes[1], target: nodes[3], sy:1, ty:-1 }, // Gate to Expert B
                    { source: nodes[1], target: nodes[4], sy:1, ty:-1 }, // Gate to Expert C
                    { source: nodes[3], target: nodes[5], sy:1, ty:-1 }  // Chosen Expert B to Output
                ];
                drawNodesAndLinks(svg, width, height, nodes, links);
            }

            createRAGDiagram();
            createFineTuneDiagram();
            createBaseModelDiagram();
            createInstructModelDiagram();
            createChatModelDiagram();
            createMoEDiagram();
        }
        
        document.addEventListener("DOMContentLoaded", function() {
            initConfigurationCharts();
            initEvaluationCharts();
            initBusinessCharts();
            initAdvancedAndModelTypeVisuals();
        });
    </script>
</body>
</html>
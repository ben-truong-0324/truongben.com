<!-- LLM Metrics at a Glance Infographic for Hugo {{< rawhtml >}} shortcode
<!-- Uses Tailwind CSS utility classes; all charts require D3.js and Tailwind loaded by parent site. -->
<!-- Keep <script> at end for D3 logic. ARIA roles added for accessibility on major chart containers. -->
    <p class=" text-slate-300 max-w-2xl mx-auto mb-10">
        Ever found yourself wondering what all those LLM metrics mean? </p>
      <p></p>From metrics for model configuration, to evaluation metrics and costs, each metric represents a different way to finetune the power of LLM solutions ever closer to your real-world problems. I made it so that you can interact with the sliders and charts below to visualize effects and tradeoffs for your convenience.
      </p>
  
      <nav aria-label="Table of Contents" class="mb-8 flex justify-center">
          <ul class="flex flex-wrap gap-2 sm:gap-4 text-sm sm:text-base font-medium">
            <li>
              <a href="#configuration" class="text-blue-400 hover:text-blue-200 underline underline-offset-2 transition">LLM Configurations</a>
            </li>
            <li>
              <a href="#metrics" class="text-blue-400 hover:text-blue-200 underline underline-offset-2 transition">Evaluation Metrics</a>
            </li>
            <li>
              <a href="#business" class="text-blue-400 hover:text-blue-200 underline underline-offset-2 transition">Business Metrics</a>
            </li>
            <!-- <li>
              <a href="#advanced" class="text-blue-400 hover:text-blue-200 underline underline-offset-2 transition">Advanced Capabilities</a>
            </li>
            <li>
              <a href="#architectures" class="text-blue-400 hover:text-blue-200 underline underline-offset-2 transition">Architectures</a>
            </li> -->
          </ul>
        </nav>
  
        
      <div class="max-w-4xl mx-auto px-2 py-10">
          
        
          <!-- LLM Configuration Parameters -->
          <section id="configuration" class="mb-16">
            <h3 class="text-xl md:text-2xl font-semibold text-slate-200 border-b border-slate-600 pb-2 mb-6">
              LLM Configuration Parameters
            </h3>
        
            <!-- Temperature -->
      <div class="bg-zinc-900 rounded-2xl shadow p-5 mb-8">
          <div class="mb-3 text-slate-300">
            <strong>Temperature</strong> controls the randomness of the model’s output. Lower values make responses more predictable and focused, while higher values increase creativity and diversity. Adjust this setting to balance reliability versus originality in generation.
          </div>
          <div class="flex flex-col md:flex-row gap-6">
            <div class="w-full md:w-1/3">
              <label for="temperature" class="block text-base font-medium text-slate-200 mb-2">
                Temperature: <span id="temp-value" class="font-bold">0.7</span>
              </label>
              <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7"
                class="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer">
              <div class="mt-4 text-sm text-slate-300 opacity-90">
                Controls randomness: Lower values make outputs more deterministic, while higher values increase creativity.
                <br><span class="text-blue-400 font-semibold">Tip:</span> Lower values for factual tasks, higher for creative writing.
              </div>
            </div>
            <div class="w-full md:w-2/3 min-h-[220px]" id="temp-chart" role="img" aria-label="Temperature token distribution chart"></div>
          </div>
          <div class="mt-6 p-4 rounded-lg bg-zinc-800 border border-zinc-700">
            <h4 class="font-medium text-slate-200 mb-2">Example Output:</h4>
            <p id="temp-example" class="text-slate-300 italic">
              "The capital of France is Paris, a beautiful city known for its iconic Eiffel Tower and rich cultural history..."
            </p>
          </div>
        </div>
        
            <!-- Top P -->
            <div class="bg-zinc-900 rounded-2xl shadow p-5 mb-8">
              <div class="flex flex-col md:flex-row gap-6">
                <div class="w-full md:w-1/3">
                  <label for="top-p" class="block text-base font-medium text-slate-200 mb-2">
                    Top P: <span id="topp-value" class="font-bold">0.9</span>
                  </label>
                  <input type="range" id="top-p" min="0.1" max="1" step="0.1" value="0.9"
                    class="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer">
                  <div class="mt-4 text-sm text-slate-300 opacity-90">
                    Nucleus sampling: Only considers tokens whose cumulative probability exceeds this threshold.
                    <br><span class="text-blue-400 font-semibold">Tip:</span> Balances diversity and quality.
                  </div>
                </div>
                <div class="w-full md:w-2/3 min-h-[220px]" id="topp-chart" role="img" aria-label="Top P nucleus sampling chart"></div>
              </div>
            </div>
        
            <!-- Top K -->
            <div class="bg-zinc-900 rounded-2xl shadow p-5 mb-8">
              <div class="flex flex-col md:flex-row gap-6">
                <div class="w-full md:w-1/3">
                  <label for="top-k" class="block text-base font-medium text-slate-200 mb-2">
                    Top K: <span id="topk-value" class="font-bold">50</span>
                  </label>
                  <input type="range" id="top-k" min="1" max="100" step="1" value="50"
                    class="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer">
                  <div class="mt-4 text-sm text-slate-300 opacity-90">
                    Limits sampling to the top K most probable tokens at each step.
                    <br><span class="text-blue-400 font-semibold">Tip:</span> Higher K increases diversity, may reduce coherence.
                  </div>
                </div>
                <div class="w-full md:w-2/3 min-h-[220px]" id="topk-chart" role="img" aria-label="Top K probability chart"></div>
              </div>
            </div>
        
            <!-- Max Tokens -->
            <div class="bg-zinc-900 rounded-2xl shadow p-5 mb-8">
              <div class="flex flex-col md:flex-row gap-6">
                <div class="w-full md:w-1/3">
                  <label for="max-tokens" class="block text-base font-medium text-slate-200 mb-2">
                    Max Tokens: <span id="maxtokens-value" class="font-bold">150</span>
                  </label>
                  <input type="range" id="max-tokens" min="20" max="500" step="10" value="150"
                    class="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer">
                  <div class="mt-4 text-sm text-slate-300 opacity-90">
                    Maximum number of tokens generated in a single response.
                    <br><span class="text-blue-400 font-semibold">Tip:</span> Balance completeness, cost, and latency.
                  </div>
                </div>
                <div class="w-full md:w-2/3 min-h-[220px]" id="maxtokens-chart" role="img" aria-label="Max tokens chart"></div>
              </div>
              <div class="mt-6 p-4 rounded-lg bg-zinc-800 border border-zinc-700">
                <h4 class="font-medium text-slate-200 mb-2">Output Length Preview:</h4>
                <p id="maxtokens-example" class="text-slate-300 italic"></p>
                <div class="w-full bg-zinc-700 rounded-full h-2.5 mt-2">
                  <div id="maxtokens-bar" class="h-2.5 rounded-full bg-blue-400" style="width: 30%"></div>
                </div>
              </div>
            </div>
        
            <!-- Frequency Penalty -->
            <div class="bg-zinc-900 rounded-2xl shadow p-5 mb-8">
              <div class="flex flex-col md:flex-row gap-6">
                <div class="w-full md:w-1/3">
                  <label for="freq-penalty" class="block text-base font-medium text-slate-200 mb-2">
                    Frequency Penalty: <span id="freqpenalty-value" class="font-bold">0.5</span>
                  </label>
                  <input type="range" id="freq-penalty" min="0" max="2" step="0.1" value="0.5"
                    class="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer">
                  <div class="mt-4 text-sm text-slate-300 opacity-90">
                    Reduces likelihood of repeating tokens.
                    <br><span class="text-blue-400 font-semibold">Tip:</span> Avoid redundancy in longer responses.
                  </div>
                </div>
                <div class="w-full md:w-2/3 min-h-[220px]" id="freqpenalty-chart" role="img" aria-label="Frequency penalty token repetition chart"></div>
              </div>
              <div class="mt-6 p-4 rounded-lg bg-zinc-800 border border-zinc-700">
                <h4 class="font-medium text-slate-200 mb-2">Token Repetition Analysis:</h4>
                <p id="freqpenalty-example" class="text-slate-300 italic"></p>
              </div>
            </div>
          </section>
        
          <!-- Evaluation Metrics for LLM Outputs -->
          <section id="metrics" class="mb-16">
            <h3 class="text-xl md:text-2xl font-semibold text-slate-200 border-b border-slate-600 pb-2 mb-6">
              Evaluation Metrics for LLM Outputs
            </h3>
            <div class="flex flex-col gap-6">
              <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Perplexity chart">
                  <h4 class="text-lg font-semibold text-blue-300 mb-3">Perplexity</h4>
                  <div class="min-h-[180px]" id="perplexity-chart"></div>
                  <p class="mt-3 text-sm text-slate-300">Lower is better for predictive accuracy.</p>
                </div>
                <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="ROUGE chart">
                  <h4 class="text-lg font-semibold text-blue-300 mb-3">ROUGE</h4>
                  <div class="min-h-[180px]" id="rouge-chart"></div>
                  <p class="mt-3 text-sm text-slate-300">Measures summarization vs. human references.</p>
                </div>
              </div>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="BLEU chart">
                  <h4 class="text-lg font-semibold text-blue-300 mb-3">BLEU</h4>
                  <div class="min-h-[180px]" id="bleu-chart"></div>
                  <p class="mt-3 text-sm text-slate-300">Translation quality vs. human references.</p>
                </div>
                <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="BERTScore chart">
                  <h4 class="text-lg font-semibold text-blue-300 mb-3">BERTScore</h4>
                  <div class="min-h-[180px]" id="bertscore-chart"></div>
                  <p class="mt-3 text-sm text-slate-300">Semantic similarity using BERT embeddings.</p>
                </div>
              </div>
              <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Hallucination rate chart">
                <h4 class="text-lg font-semibold text-blue-300 mb-3">Hallucination Rate</h4>
                <div class="min-h-[180px]" id="hallucination-chart"></div>
                <p class="mt-3 text-sm text-slate-300">Factually unsupported outputs (lower is better).</p>
              </div>
            </div>
          </section>
        
          <!-- Business-Oriented Metrics -->
          <section id="business" class="mb-16">
            <h3 class="text-xl md:text-2xl font-semibold text-slate-200 border-b border-slate-600 pb-2 mb-6">
              Business-Oriented Metrics
            </h3>
            <div class="flex flex-col gap-6">
              <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Latency chart">
                  <h4 class="text-lg font-semibold text-blue-300 mb-3">Latency Comparison</h4>
                  <div class="min-h-[180px]" id="latency-chart"></div>
                  <p class="mt-3 text-sm text-slate-300">Response time across top models.</p>
                </div>
                <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Cost chart">
                  <h4 class="text-lg font-semibold text-blue-300 mb-3">Cost per Token</h4>
                  <div class="min-h-[180px]" id="cost-chart"></div>
                  <p class="mt-3 text-sm text-slate-300">Compare model pricing per 1k tokens.</p>
                </div>
              </div>
            </div>
          </section>
        
          <!-- Advanced Capabilities -->
          <!-- <section id="advanced" class="mb-16">
            <h3 class="text-xl md:text-2xl font-semibold text-slate-200 border-b border-slate-600 pb-2 mb-6">
           Advanced Capabilities
            </h3>
            <div class="flex flex-col gap-6">
              <div class="bg-zinc-900 rounded-2xl shadow p-5 mb-2" role="region" aria-label="Retrieval-Augmented Generation diagram">
                <h4 class="text-lg font-semibold text-blue-300 mb-3">Retrieval-Augmented Generation (RAG)</h4>
                <div class="min-h-[180px]" id="rag-diagram"></div>
                <p class="mt-3 text-sm text-slate-300">Combines LLMs with retrieval for factual accuracy.</p>
              </div>
              <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Fine-tuning diagram">
                <h4 class="text-lg font-semibold text-blue-300 mb-3">Fine-Tuning Process</h4>
                <div class="min-h-[180px]" id="finetune-diagram"></div>
                <p class="mt-3 text-sm text-slate-300">Adapts base model to specialized tasks.</p>
              </div>
            </div>
          </section> -->
        
          <!-- LLM Model Architectures -->
          <!-- <section id="architectures" class="mb-16">
            <h3 class="text-xl md:text-2xl font-semibold text-slate-200 border-b border-slate-600 pb-2 mb-6">
              Understanding LLM Model Architectures
            </h3>
            <div class="flex flex-col gap-6">
              <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Base model diagram">
                <h4 class="text-lg font-semibold text-blue-300 mb-3">Base Model</h4>
                <p class="text-slate-300 mb-2">
                  Trained for next-token prediction on broad data. Foundation for all other LLM types.
                </p>
                <div class="min-h-[150px]" id="base-model-diagram"></div>
              </div>
              <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Instruct model diagram">
                <h4 class="text-lg font-semibold text-blue-300 mb-3">Instruct Model</h4>
                <p class="text-slate-300 mb-2">
                  Fine-tuned for following instructions from (instruction, response) pairs.
                </p>
                <div class="min-h-[150px]" id="instruct-model-diagram"></div>
              </div>
              <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Chat model diagram">
                <h4 class="text-lg font-semibold text-blue-300 mb-3">Chat Model</h4>
                <p class="text-slate-300 mb-2">
                  Further optimized for dialogue, context, and alignment with user intent.
                </p>
                <div class="min-h-[150px]" id="chat-model-diagram"></div>
              </div>
              <div class="bg-zinc-900 rounded-2xl shadow p-5" role="region" aria-label="Mixture of Experts diagram">
                <h4 class="text-lg font-semibold text-blue-300 mb-3">Mixture of Experts (MoE)</h4>
                <p class="text-slate-300 mb-2">
                  Routes input tokens to specialized "expert" sub-models for efficient scaling.
                </p>
                <div class="min-h-[150px]" id="moe-model-diagram"></div>
              </div>
            </div>
          </section>
        
          <footer class="mt-16 text-center text-xs text-slate-400 opacity-70">
            <p>Interactive LLM Metrics Guide &mdash; For educational purposes only. Data simulated for demo.</p>
          </footer>
        </div> -->
        
        <!-- D3 & Chart logic (REQUIRES: d3.js, tailwind.css already included by Hugo) -->
        <script src="https://d3js.org/d3.v7.min.js"></script>
        <script>
          // Tooltip setup
          const tooltip = d3.select("body").append("div")
    .attr("class", "tooltip")
    .style("opacity", 0)
    .style("background", "#0c4a6e") // deep blue (tw-blue-900)
    .style("color", "#fde68a") // yellow-200 for high contrast
    .style("fontWeight", "bold")
    .style("borderRadius", "0.375rem")
    .style("padding", "10px")
    .style("pointerEvents", "none")
    .style("fontSize", "15px")
    .style("zIndex", "99");
  
          // Get colors from CSS variables
          const tuftsBlue = getComputedStyle(document.documentElement).getPropertyValue('--tufts-blue').trim();
          const gunmetal = getComputedStyle(document.documentElement).getPropertyValue('--gunmetal').trim();
          const ghostWhite = getComputedStyle(document.documentElement).getPropertyValue('--ghost-white').trim();
          const chiliRed = getComputedStyle(document.documentElement).getPropertyValue('--chili-red').trim();
          const xanthous = getComputedStyle(document.documentElement).getPropertyValue('--xanthous').trim();
          const diagramNodeText = getComputedStyle(document.documentElement).getPropertyValue('--diagram-node-text').trim();
  
          const colorScale = d3.scaleSequential(d3.interpolate(ghostWhite, tuftsBlue)).domain([0, 1]);
          const vendorColor = d3.scaleOrdinal().domain(["OpenAI", "Anthropic", "Open Source"]).range([tuftsBlue, chiliRed, xanthous]);
  
          function generateRandomData(count, min, max) {
              return Array.from({length: count}, () => Math.random() * (max - min) + min);
          }
  
          // Section 1: Configuration Parameters ( 그대로 유지, CSS 변수 사용 확인 )
           function initConfigurationCharts() {
              function updateBarChart(chartId, data, xDomainFormat = i => i, yTickFormat = d => `${(d*100).toFixed(0)}%`, chartTitle = "Token Probability Distribution", highlightCondition = (d,i,value) => false, highlightColor = chiliRed, baseColor = tuftsBlue, lineValue = null, lineColor = chiliRed) {
                  const margin = {top: 30, right: 20, bottom: 40, left: 50};
                  const container = document.getElementById(chartId);
                  if (!container) return;
                  const width = container.clientWidth - margin.left - margin.right;
                  const height = 250 - margin.top - margin.bottom;
                  
                  d3.select(`#${chartId}`).selectAll("*").remove();
                  
                  const svg = d3.select(`#${chartId}`)
                      .append("svg")
                      .attr("width", width + margin.left + margin.right)
                      .attr("height", height + margin.top + margin.bottom)
                      .append("g")
                      .attr("transform", `translate(${margin.left},${margin.top})`);
                  
                  const x = d3.scaleBand()
                      .domain(d3.range(data.length))
                      .range([0, width])
                      .padding(0.1);
                  
                  const y = d3.scaleLinear()
                      .domain([0, d3.max(data) > 0 ? d3.max(data) : 1]) 
                      .range([height, 0]);
                  
                  svg.selectAll(".bar")
                      .data(data)
                      .enter()
                      .append("rect")
                      .attr("class", "token-probability-bar")
                      .attr("x", (d, i) => x(i))
                      .attr("y", d => y(d))
                      .attr("width", x.bandwidth())
                      .attr("height", d => height - y(d))
                      .attr("fill", (d, i) => highlightCondition(d,i, lineValue ? lineValue.value : null) ? highlightColor : baseColor) 
                      .on("mouseover", function(event, d_val) {
                          tooltip.transition().duration(200).style("opacity", .9);
                          tooltip.html(`Probability: ${(d_val*100).toFixed(1)}%`)
                              .style("left", (event.pageX + 5) + "px")
                              .style("top", (event.pageY - 28) + "px");
                      })
                      .on("mouseout", function() {
                          tooltip.transition().duration(500).style("opacity", 0);
                      });
                  
                  svg.append("g")
                      .attr("transform", `translate(0,${height})`)
                      .call(d3.axisBottom(x).tickFormat(xDomainFormat).tickSize(0));
                  
                  svg.append("g")
                      .call(d3.axisLeft(y).ticks(5).tickFormat(yTickFormat));
                  
                  svg.append("text")
                      .attr("x", width/2)
                      .attr("y", -10)
                      .attr("text-anchor", "middle")
                      .style("fill", gunmetal)
                      .text(chartTitle);
  
                  if (lineValue !== null && typeof lineValue.value !== 'undefined' && typeof lineValue.text !== 'undefined' ) { 
                       if (lineValue.isVertical) {
                          const lineX = x(lineValue.value -0.5);
                          if (typeof lineX !== 'undefined') { // Check if x value is valid
                              svg.append("line")
                                  .attr("x1", lineX )
                                  .attr("x2", lineX )
                                  .attr("y1", 0)
                                  .attr("y2", height)
                                  .attr("stroke", lineColor)
                                  .attr("stroke-width", 2)
                                  .attr("stroke-dasharray", "5,5");
                              svg.append("text")
                                  .attr("x", lineX + 5)
                                  .attr("y", 20)
                                  .text(lineValue.text)
                                  .style("fill", lineColor);
                          }
                       } else {
                          svg.append("line")
                              .attr("x1", 0)
                              .attr("x2", width)
                              .attr("y1", y(lineValue.value))
                              .attr("y2", y(lineValue.value))
                              .attr("stroke", lineColor)
                              .attr("stroke-width", 2)
                              .attr("stroke-dasharray", "5,5");
                          svg.append("text")
                              .attr("x", width - 10)
                              .attr("y", y(lineValue.value) - 5)
                              .attr("text-anchor", "end")
                              .text(lineValue.text)
                              .style("fill", lineColor);
                       }
                  }
              }
  
              function updateTempChart(value) { /* ... same as before, ensure baseColor=tuftsBlue ... */
                  let data = generateRandomData(15, 0.01, 1); 
                  data.sort((a, b) => b - a);
                  const tempData = data.map(d => Math.exp(Math.log(d) / value));
                  const sumTempData = tempData.reduce((sum, val) => sum + val, 0);
                  const normalizedTempData = sumTempData > 0 ? tempData.map(d => d / sumTempData) : Array(tempData.length).fill(0);
                  updateBarChart('temp-chart', normalizedTempData, i => (i === 0 ? "Most likely" : ""), d => `${(d*100).toFixed(0)}%`, "Token Probability (Temperature Adjusted)", (d,i,v) => false, chiliRed, tuftsBlue);
              }
              function updateTopPChart(value) { /* ... same, ensure colors from palette ... */
                  let data = generateRandomData(15, 0, 1);
                  data.sort((a, b) => b - a);
                  const sumProbs = data.reduce((s, p) => s + p, 0);
                  const normalizedData = sumProbs > 0 ? data.map(p => p / sumProbs) : Array(data.length).fill(0);
                  let cumulativeProb = 0;
                  const displayData = normalizedData.map(p => {
                      const originalCumulative = cumulativeProb;
                      cumulativeProb += p;
                      return { prob: p, inNucleus: originalCumulative < value };
                  });
                  updateBarChart('topp-chart', displayData.map(d => d.prob), i => (i === 0 ? "Most likely" : ""), d => `${(d*100).toFixed(0)}%`, "Token Probabilities (Top-P Nucleus)", (d, i, val) => !displayData[i].inNucleus, '#cccccc', tuftsBlue, { value: value, text: `Top P = ${value.toFixed(1)}`, isVertical: false }, chiliRed);
              }
              function updateTopKChart(value) { /* ... same, ensure colors from palette ... */
                  let data = generateRandomData(20, 0, 1);
                  data.sort((a, b) => b - a);
                  const sumProbs = data.reduce((s, p) => s + p, 0);
                  const normalizedData = sumProbs > 0 ? data.map(p => p / sumProbs) : Array(data.length).fill(0);
                  updateBarChart('topk-chart', normalizedData, i => (i === 0 ? "Most likely" : ""), d => `${(d*100).toFixed(0)}%`, "Token Probabilities (Top-K Highlighted)", (d,i) => i >= value, '#cccccc', tuftsBlue, { value: value, text: `Top K = ${value}`, isVertical: true }, chiliRed);
              }
              function updateMaxTokensChart(value) { /* ... same, ensure colors ... */
                  const sampleText = "Large language models are transforming how we interact with technology. These AI systems can understand and generate human-like text, enabling applications like chatbots, content creation, and code generation. The key advantage is their ability to handle a wide range of tasks without task-specific training. However, they require careful tuning of parameters like temperature and top-p sampling to produce optimal results. When configured properly, they can significantly enhance productivity across many industries.";
                  d3.select("#maxtokens-chart").selectAll("*").remove();
                  const margin = {top: 30, right: 20, bottom: 40, left: 50};
                  const container = document.getElementById('maxtokens-chart');
                  if (!container) return;
                  const width = container.clientWidth - margin.left - margin.right;
                  const height = 250 - margin.top - margin.bottom;
                  const svg = d3.select("#maxtokens-chart").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                  const x = d3.scaleLinear().domain([0, 500]).range([0, width]);
                  svg.append("rect").attr("x", 0).attr("y", height * 0.4).attr("width", x(value)).attr("height", height * 0.2).attr("fill", tuftsBlue);
                  svg.append("line").attr("x1", x(value)).attr("x2", x(value)).attr("y1", 0).attr("y2", height).attr("stroke", chiliRed).attr("stroke-width", 2).attr("stroke-dasharray", "5,5");
                  svg.append("text").attr("x", x(value) > 30 ? x(value) - 5 : x(value) + 5).attr("y", height * 0.3).attr("text-anchor", x(value) > 30 ? "end" : "start").text(`${value} tokens`).style("fill", chiliRed);
                  svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(5));
                  svg.append("text").attr("x", width/2).attr("y", -10).attr("text-anchor", "middle").style("fill", gunmetal).text("Output Token Limit");
                  const approxWords = Math.floor(value * 0.75);
                  const truncatedText = sampleText.split(" ").slice(0, approxWords).join(" ");
                  document.getElementById("maxtokens-example").textContent = truncatedText + (value < 500 ? "..." : "");
                  document.getElementById("maxtokens-bar").style.width = `${(value/500)*100}%`;
              }
              function updateFreqPenaltyChart(value) { /* ... same, ensure colors ... */
                  const tokens = ["the", "fox", "is", "quick", "brown", "dog"];
                  const baseProbs = [0.25, 0.1, 0.15, 0.2, 0.15, 0.15];
                  const penalizedProbs = baseProbs.map(p => Math.max(0, p - (value * p * 0.5))); 
                  const data = tokens.map((token, i) => ({token, base: baseProbs[i], adjusted: penalizedProbs[i]}));
                  d3.select("#freqpenalty-chart").selectAll("*").remove();
                  const margin = {top: 30, right: 20, bottom: 40, left: 50};
                  const container = document.getElementById('freqpenalty-chart');
                  if(!container) return;
                  const width = container.clientWidth - margin.left - margin.right;
                  const height = 250 - margin.top - margin.bottom;
                  const svg = d3.select("#freqpenalty-chart").append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                  const x = d3.scaleBand().domain(tokens).range([0, width]).padding(0.2);
                  const y = d3.scaleLinear().domain([0, d3.max(baseProbs)]).range([height, 0]);
                  svg.selectAll(".base-bar").data(data).enter().append("rect").attr("x", d => x(d.token)).attr("y", d => y(d.base)).attr("width", x.bandwidth() / 2).attr("height", d => height - y(d.base)).attr("fill", "#cccccc");
                  svg.selectAll(".adj-bar").data(data).enter().append("rect").attr("x", d => x(d.token) + x.bandwidth() / 2).attr("y", d => y(d.adjusted)).attr("width", x.bandwidth() / 2).attr("height", d => height - y(d.adjusted)).attr("fill", tuftsBlue);
                  svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
                  svg.append("g").call(d3.axisLeft(y).ticks(5).tickFormat(d => `${(d*100).toFixed(0)}%`));
                  svg.append("text").attr("x", width/2).attr("y", -10).attr("text-anchor", "middle").style("fill", gunmetal).text("Token Probability (Base vs. Penalized)");
                  let example = "";
                  tokens.forEach((token, i) => { const reps = Math.max(1, Math.round(penalizedProbs[i] * 10)); example += `${token} `.repeat(reps > 0 ? reps : 1); });
                  document.getElementById("freqpenalty-example").textContent = example.trim() + "...";
              }
              
              updateTempChart(parseFloat(document.getElementById("temperature").value));
              updateTopPChart(parseFloat(document.getElementById("top-p").value));
              updateTopKChart(parseInt(document.getElementById("top-k").value));
              updateMaxTokensChart(parseInt(document.getElementById("max-tokens").value));
              updateFreqPenaltyChart(parseFloat(document.getElementById("freq-penalty").value));
              
              document.getElementById("temperature").addEventListener("input", function() { const val = parseFloat(this.value); document.getElementById("temp-value").textContent = val.toFixed(1); updateTempChart(val); /* example text update */ });
              document.getElementById("top-p").addEventListener("input", function() { const val = parseFloat(this.value); document.getElementById("topp-value").textContent = val.toFixed(1); updateTopPChart(val); });
              document.getElementById("top-k").addEventListener("input", function() { const val = parseInt(this.value); document.getElementById("topk-value").textContent = val; updateTopKChart(val); });
              document.getElementById("max-tokens").addEventListener("input", function() { const val = parseInt(this.value); document.getElementById("maxtokens-value").textContent = val; updateMaxTokensChart(val); });
              document.getElementById("freq-penalty").addEventListener("input", function() { const val = parseFloat(this.value); document.getElementById("freqpenalty-value").textContent = val.toFixed(1); updateFreqPenaltyChart(val); });
          }
  
          // Section 2: Evaluation Metrics ( 그대로 유지, CSS 변수 사용 확인 )
          function initEvaluationCharts() { /* ... same as before, ensuring barFillColors use new palette vars ... */ 
              function createSimpleBarChart(chartId, data, xLabel, yLabel, yDomain = [0,1], barFillColor = tuftsBlue, valueFormat = d => d.toFixed(2)) {
                  const margin = {top: 30, right: 20, bottom: 50, left: 60};
                  const container = document.getElementById(chartId);
                  if (!container) return;
                  const width = container.clientWidth - margin.left - margin.right;
                  const height = 200 - margin.top - margin.bottom;
                  d3.select(`#${chartId}`).selectAll("*").remove();
                  const svg = d3.select(`#${chartId}`).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                  const x = d3.scaleBand().domain(data.map(d => d.name)).range([0, width]).padding(0.2);
                  const y = d3.scaleLinear().domain(yDomain).range([height, 0]);
                  svg.selectAll(".bar").data(data).enter().append("rect").attr("x", d => x(d.name)).attr("y", d => y(d.value)).attr("width", x.bandwidth()).attr("height", d => height - y(d.value)).attr("fill", barFillColor);
                  svg.selectAll(".bar-value").data(data).enter().append("text").attr("x", d => x(d.name) + x.bandwidth() / 2).attr("y", d => y(d.value) - 5).attr("text-anchor", "middle").style("font-size", "10px").style("fill", gunmetal).text(d => valueFormat(d.value));
                  svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
                  svg.append("g").call(d3.axisLeft(y).ticks(5).tickFormat(yDomain[1] <=1 && yLabel.toLowerCase().includes("score") ? d3.format(".0%") : d3.format(",")));
                  svg.append("text").attr("x", width/2).attr("y", height + margin.bottom - 15).attr("text-anchor", "middle").style("fill", gunmetal).text(xLabel);
                  svg.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left + 15).attr("x", -height/2).attr("text-anchor", "middle").style("fill", gunmetal).text(yLabel);
              }
              createSimpleBarChart('perplexity-chart', [{name: "M1", value:30}, {name:"M2", value:22}, {name:"M3", value:45}], "Model", "Perplexity", [0,60], chiliRed, d => d.toFixed(0));
              createSimpleBarChart('rouge-chart', [{name: "R-1", value:0.45}, {name:"R-2", value:0.32}, {name:"R-L", value:0.40}], "ROUGE Metric", "F1 Score", [0,1], tuftsBlue);
              createSimpleBarChart('bleu-chart', [{name: "SysA", value:28}, {name:"SysB", value:35}, {name:"SysC", value:31}], "System", "BLEU Score", [0,50], xanthous, d => d.toFixed(0));
              createSimpleBarChart('bertscore-chart', [{name: "OutX", value:0.88}, {name:"OutY", value:0.92}, {name:"OutZ", value:0.85}], "Output", "BERTScore F1", [0.8,1], tuftsBlue); // BERTScore typically 0-1
              createSimpleBarChart('hallucination-chart', [{name: "M-Base", value:0.15}, {name:"M-Tuned", value:0.06}, {name:"M-RAG", value:0.03}], "Model Config", "Hallucination Rate", [0,0.2], chiliRed);
          }
  
  
          // Section 3: Business Metrics ( 그대로 유지, CSS 변수 사용 확인 )
          function initBusinessCharts() { /* ... same as before, ensuring barFillColors use new palette vars ... */ 
              function createLatencyCostChart(chartId, data, xLabel, yLabel, yDomain, barFillColors = [tuftsBlue, xanthous, chiliRed], valueFormat = d => d.toFixed(0)) {
                  const margin = {top: 30, right: 20, bottom: 50, left: 60};
                  const container = document.getElementById(chartId);
                  if (!container) return;
                  const width = container.clientWidth - margin.left - margin.right;
                  const height = 200 - margin.top - margin.bottom; 
                  d3.select(`#${chartId}`).selectAll("*").remove();
                  const svg = d3.select(`#${chartId}`).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
                  const x = d3.scaleBand().domain(data.map(d => d.name)).range([0, width]).padding(0.2);
                  const y = d3.scaleLinear().domain(yDomain).range([height, 0]);
                  svg.selectAll(".bar").data(data).enter().append("rect").attr("x", d => x(d.name)).attr("y", d => y(d.value)).attr("width", x.bandwidth()).attr("height", d => height - y(d.value)).attr("fill", (d,i) => barFillColors[i % barFillColors.length]);
                  svg.selectAll(".bar-value").data(data).enter().append("text").attr("x", d => x(d.name) + x.bandwidth() / 2).attr("y", d => y(d.value) - 5).attr("text-anchor", "middle").style("font-size", "10px").style("fill", gunmetal).text(d => valueFormat(d.value));
                  svg.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x));
                  svg.append("g").call(d3.axisLeft(y).ticks(5).tickFormat(yLabel.toLowerCase().includes("cost") ? d3.format("$.3f") : d3.format(",")));
                  svg.append("text").attr("x", width/2).attr("y", height + margin.bottom - 15).attr("text-anchor", "middle").style("fill", gunmetal).text(xLabel);
                  svg.append("text").attr("transform", "rotate(-90)").attr("y", -margin.left + 15).attr("x", -height/2).attr("text-anchor", "middle").style("fill", gunmetal).text(yLabel);
              }
              createLatencyCostChart('latency-chart', [{name: "GPT-4o", value:350}, {name:"Claude-3S", value:450}, {name:"Llama3-70B", value:600}], "Model Provider", "Latency (ms)", [0,800], [tuftsBlue, xanthous, chiliRed], d => `${d}ms`);
              createLatencyCostChart('cost-chart', [{name: "GPT-4o", value:0.005}, {name:"Claude-3S", value:0.003}, {name:"Llama3-70B", value:0.001}], "Model Provider", "Cost per 1k Tokens ($)", [0,0.007], [tuftsBlue, xanthous, chiliRed], d => `$${d.toFixed(3)}`);
          }
  
  
          // Section 4 & 5: Advanced Capabilities & Model Types
          function initAdvancedAndModelTypeVisuals() {
              const nodeW = 100, nodeH = 40, nodeRx = 5, nodeRy = 5;
              const textColor = diagramNodeText; // White text on dark nodes
              const lineColor = gunmetal;
  
              // Helper to create a standard diagram SVG
              function createDiagramSvg(containerId) {
                  const margin = {top: 20, right: 20, bottom: 20, left: 20};
                  const container = document.getElementById(containerId);
                   if (!container) { console.error(`Container ${containerId} not found`); return null;}
                  d3.select(`#${containerId}`).selectAll("*").remove(); // Clear previous
                  const width = container.clientWidth - margin.left - margin.right;
                  const height = parseFloat(d3.select(container).style('min-height')) - margin.top - margin.bottom -10; // use min-height from style
  
                  const svg = d3.select(`#${containerId}`)
                      .append("svg")
                      .attr("width", width + margin.left + margin.right)
                      .attr("height", height + margin.top + margin.bottom)
                      .append("g")
                      .attr("transform", `translate(${margin.left},${margin.top})`);
                  
                  // Define arrowhead (once per page is better, but this is robust)
                  if (!d3.select("defs marker#arrowhead").node()) {
                      svg.append("defs").append("marker")
                          .attr("id", "arrowhead")
                          .attr("viewBox", "0 -5 10 10")
                          .attr("refX", 8)
                          .attr("refY", 0)
                          .attr("orient", "auto")
                          .attr("markerWidth", 6)
                          .attr("markerHeight", 6)
                          .append("path")
                          .attr("d", "M0,-5L10,0L0,5")
                          .attr("fill", lineColor);
                  }
                  return { svg, width, height };
              }
  
              function drawNodesAndLinks(svg, width, height, nodesSpec, linksSpec) {
                  nodesSpec.forEach(node => {
                      svg.append("rect")
                          .attr("x", node.x - node.w/2)
                          .attr("y", node.y - node.h/2)
                          .attr("width", node.w)
                          .attr("height", node.h)
                          .attr("rx", nodeRx).attr("ry", nodeRy)
                          .attr("fill", node.color)
                          .attr("stroke", lineColor);
                      svg.append("text")
                          .attr("x", node.x)
                          .attr("y", node.y)
                          .attr("text-anchor", "middle").attr("dy", "0.35em")
                          .text(node.text).style("fill", textColor).style("font-size", "10px");
                  });
  
                  linksSpec.forEach(link => {
                      svg.append("path")
                          .attr("d", `M${link.source.x + link.source.w/2 * (link.sx || 0)},${link.source.y + link.source.h/2 * (link.sy || 0)} L${link.target.x - link.target.w/2 * (link.tx || 0)},${link.target.y - link.target.h/2 * (link.ty || 0)}`)
                          .attr("stroke", lineColor).attr("stroke-width", 2).attr("fill", "none")
                          .attr("marker-end", "url(#arrowhead)");
                  });
              }
              
              // RAG Diagram (Restored from original logic)
              function createRAGDiagram() {
                  const res = createDiagramSvg('rag-diagram');
                  if (!res) return;
                  const { svg, width, height } = res;
  
                  constcenterY = height / 2;
                  const nodeWidth = width / 5;
                  const gap = 20;
  
                  const nodes = [
                      { id: "query", x: nodeWidth * 0.5, y: centerY, w: nodeW, h: nodeH, text: "User Query", color: tuftsBlue },
                      { id: "retriever", x: nodeWidth * 1.5 + gap, y: centerY, w: nodeW, h: nodeH, text: "Retriever", color: xanthous },
                      { id: "docs", x: nodeWidth * 2.5 + gap*2, y: centerY - nodeH, w: nodeW, h: nodeH, text: "Documents", color: ghostWhite, colorText: gunmetal }, // Use ghostWhite for docs
                      { id: "llm", x: nodeWidth * 2.5 + gap*2, y: centerY + nodeH, w: nodeW, h: nodeH, text: "LLM", color: chiliRed },
                      { id: "response", x: nodeWidth * 4 + gap*3, y: centerY, w: nodeW, h: nodeH, text: "Response", color: gunmetal }
                  ];
                   nodes.find(n=>n.id==="docs").textColor = gunmetal; // Special case for light background
  
                  const links = [
                      { source: nodes[0], target: nodes[1], sx:1, tx:1 }, // Query -> Retriever
                      { source: nodes[1], target: nodes[2], sx:1, ty:-1, tx:1 }, // Retriever -> Docs (upper)
                      { source: nodes[1], target: nodes[3], sx:1, ty:1, tx:1  }, // Retriever -> LLM (lower)
                      { source: nodes[2], target: nodes[4], sx:1, tx:1 }, // Docs -> Response
                      { source: nodes[3], target: nodes[4], sx:1, tx:1 }  // LLM -> Response
                  ];
                  
                  nodes.forEach(node => {
                      svg.append("rect").attr("x", node.x - node.w/2).attr("y", node.y - node.h/2).attr("width", node.w).attr("height", node.h).attr("rx", nodeRx).attr("ry", nodeRy).attr("fill", node.color).attr("stroke", lineColor);
                      svg.append("text").attr("x", node.x).attr("y", node.y).attr("text-anchor", "middle").attr("dy", "0.35em").text(node.text).style("fill", node.textColor || textColor).style("font-size", "10px");
                  });
                  links.forEach(link => {
                      let sourceNode = link.source; let targetNode = link.target;
                      svg.append("path").attr("d", `M${sourceNode.x + sourceNode.w/2},${sourceNode.y} L${targetNode.x-targetNode.w/2},${targetNode.y}`).attr("stroke", lineColor).attr("stroke-width", 2).attr("fill", "none").attr("marker-end", "url(#arrowhead)");
                  });
              }
  
              // Fine-Tune Diagram (Restored from original logic)
              function createFineTuneDiagram() {
                  const res = createDiagramSvg('finetune-diagram');
                   if (!res) return;
                  const { svg, width, height } = res;
  
                  const nodeRadius = width / 12; // Circle radius based on width
                  constcenterY = height / 2;
                  const stepX = width / 4.5;
  
                  const nodes = [
                      { x: stepX * 0.7, y: centerY, text: "Base Model", color: tuftsBlue, r: nodeRadius },
                      { x: stepX * 1.7, y: centerY, text: "Domain Data", color: xanthous, r: nodeRadius },
                      { x: stepX * 2.7, y: centerY, text: "Training", color: chiliRed, r: nodeRadius },
                      { x: stepX * 3.7, y: centerY, text: "Fine-Tuned", color: gunmetal, r: nodeRadius }
                  ];
  
                  nodes.forEach((node, i) => {
                      svg.append("circle").attr("cx", node.x).attr("cy", node.y).attr("r", node.r).attr("fill", node.color).attr("stroke", lineColor);
                      svg.append("text").attr("x", node.x).attr("y", node.y).attr("text-anchor", "middle").attr("dy", "0.35em").text(i+1).style("fill", textColor).style("font-size", "12px");
                      svg.append("text").attr("x", node.x).attr("y", node.y + node.r + 15).attr("text-anchor", "middle").text(node.text).style("font-size", "10px").style("fill", gunmetal);
                  });
  
                  for (let i = 0; i < nodes.length - 1; i++) {
                      svg.append("line").attr("x1", nodes[i].x + nodes[i].r).attr("y1", nodes[i].y).attr("x2", nodes[i+1].x - nodes[i+1].r).attr("y2", nodes[i+1].y).attr("stroke", lineColor).attr("stroke-width", 2).attr("marker-end", i === nodes.length - 2 ? "url(#arrowhead)" : null);
                  }
              }
              
              // New Model Type Diagrams
              function createBaseModelDiagram() {
                  const res = createDiagramSvg('base-model-diagram'); if (!res) return;
                  const { svg, width, height } = res;
                  const nodes = [ { x: width/4, y: height/2, w:nodeW, h:nodeH, text: "Input: 'The sky is'", color: tuftsBlue }, { x: 3*width/4, y: height/2, w:nodeW, h:nodeH, text: "Output: '...blue'", color: gunmetal } ];
                  const links = [ { source: nodes[0], target: nodes[1], sx:1, tx:1 } ];
                  drawNodesAndLinks(svg, width, height, nodes, links);
              }
  
              function createInstructModelDiagram() {
                  const res = createDiagramSvg('instruct-model-diagram'); if (!res) return;
                  const { svg, width, height } = res;
                  const nodes = [ { x: width/4, y: height/2, w:nodeW+20, h:nodeH+10, text: "Instruction: 'Summarize this text...'", color: xanthous }, { x: 3*width/4, y: height/2, w:nodeW+20, h:nodeH, text: "Output: '[Concise Summary]'", color: gunmetal } ];
                  const links = [ { source: nodes[0], target: nodes[1], sx:1, tx:1 } ];
                  drawNodesAndLinks(svg, width, height, nodes, links);
              }
  
              function createChatModelDiagram() {
                  const res = createDiagramSvg('chat-model-diagram'); if (!res) return;
                  const { svg, width, height } = res;
                  const nodeWidth = width / 3.5;
                  const nodes = [
                      { x: nodeWidth * 0.7, y: height/3, w:nodeW, h:nodeH, text: "User: 'Hi!'", color: tuftsBlue },
                      { x: nodeWidth * 2.3, y: height/3, w:nodeW, h:nodeH, text: "LLM: 'Hello!'", color: gunmetal },
                      { x: nodeWidth * 0.7, y: 2*height/3, w:nodeW, h:nodeH, text: "User: 'Weather?'", color: tuftsBlue },
                      { x: nodeWidth * 2.3, y: 2*height/3, w:nodeW, h:nodeH, text: "LLM: 'Sunny.' (Context)", color: gunmetal }
                  ];
                  const links = [
                      { source: nodes[0], target: nodes[1], sx:1, tx:1 }, { source: nodes[1], target: nodes[2], sy:1, ty:-1 }, // LLM -> Next User (conceptually)
                      { source: nodes[2], target: nodes[3], sx:1, tx:1 }
                  ];
                  drawNodesAndLinks(svg, width, height, nodes, links);
              }
  
              function createMoEDiagram() {
                  const res = createDiagramSvg('moe-model-diagram'); if (!res) return;
                  const { svg, width, height } = res;
                  constcenterY = height / 2;
                  constcenterX = width / 2;
                  const expertYOffset = 50;
                  const expertXSpread = 60;
  
                  const nodes = [
                      { x: centerX, y: centerY - 70, w:nodeW, h:nodeH, text: "Input Token", color: tuftsBlue },
                      { x: centerX, y: centerY - 25, w:nodeW, h:nodeH, text: "Gating Network", color: xanthous },
                      { x: centerX - expertXSpread, y: centerY + expertYOffset, w:nodeW-20, h:nodeH-10,text: "Expert A", color: chiliRed },
                      { x: centerX, y: centerY + expertYOffset, w:nodeW-20, h:nodeH-10,text: "Expert B", color: chiliRed, stroke: tuftsBlue, strokeW: 3 }, // Highlighted expert
                      { x: centerX + expertXSpread, y: centerY + expertYOffset, w:nodeW-20, h:nodeH-10,text: "Expert C", color: chiliRed },
                      { x: centerX, y: centerY + expertYOffset + 60, w:nodeW, h:nodeH,text: "Combined Output", color: gunmetal }
                  ];
                   nodes.forEach(node => { // Add stroke to highlighted
                      if(node.stroke) {
                          svg.append("rect").attr("x", node.x - node.w/2 - node.strokeW).attr("y", node.y - node.h/2-node.strokeW)
                             .attr("width", node.w + 2*node.strokeW).attr("height", node.h+2*node.strokeW)
                             .attr("rx", nodeRx+node.strokeW).attr("ry", nodeRy+node.strokeW).attr("fill", node.stroke);
                      }
                  });
  
                  const links = [
                      { source: nodes[0], target: nodes[1], sy:1, ty:-1 },
                      { source: nodes[1], target: nodes[2], sy:1, ty:-1 }, // Gate to Expert A
                      { source: nodes[1], target: nodes[3], sy:1, ty:-1 }, // Gate to Expert B
                      { source: nodes[1], target: nodes[4], sy:1, ty:-1 }, // Gate to Expert C
                      { source: nodes[3], target: nodes[5], sy:1, ty:-1 }  // Chosen Expert B to Output
                  ];
                  drawNodesAndLinks(svg, width, height, nodes, links);
              }
  
              createRAGDiagram();
              createFineTuneDiagram();
              createBaseModelDiagram();
              createInstructModelDiagram();
              createChatModelDiagram();
              createMoEDiagram();
          }
          
          document.addEventListener("DOMContentLoaded", function() {
              initConfigurationCharts();
              initEvaluationCharts();
              initBusinessCharts();
              initAdvancedAndModelTypeVisuals();
          });
      </script>
  